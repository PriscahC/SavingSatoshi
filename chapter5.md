# Chapter 5: Digital Signatures & Verification

## ðŸ” Don't Trust, Verify

We can use Elliptic Curve math to derive a public key from a private key. The public key can be shared as a unique identifier and the private key is used to prove a person has control of that identifier. That proof is called a **SIGNATURE**.

### How Signatures Work

- **To create a signature:** You need a message and a private key
- **To verify a signature:** Anyone can verify it with a copy of the message and the corresponding public key

---

## Finding Satoshi's Signature

### Block #170: The First Bitcoin Transaction

[Block #170](https://blockstream.info/tx/f4184fc596403b9d638783cf57adfe4c75c605f6356fbc91338530e9831e9e16?expand) contains the first bitcoin transaction made from Satoshi to Hal Finney. 

**Task:** Retrieve the scriptSig from the input - it contains Satoshi's signature!

```
scriptSig (asm)
OP_PUSHBYTES_71 304402204e45e16932b8af514961a1d3a1a25fdf3f4f7732e9d624c6c61548ab5fb8cd410220181522ec8eca07de4860a4acdd12909d831cc56cbbac4622082221a8768d1d0901
```

---

## Locating Satoshi's Public Key

The public key is stored along with the bitcoin Satoshi generated by mining [block #9](https://blockstream.info/tx/0437cd7f8525ceed2324359c2d0ba26006d92d856a9c20fa0241106ee5a597c9?output:0&expand).

The public key lives between the script commands `OP_PUSHBYTES` and `OP_CHECKSIG`:

```
0411db93e1dcdb8a016b49840f8c53bc1eb68a382e97b1482ecad7b148a6909a5cb2e0eaddfb84ccf9744464f82e160bfa9b8b64f9d4c03f999b8643f656b412a3
```

---

## Deriving the Message from the Transaction

The Bitcoin protocol has a very specific algorithm for creating messages from transactions so they can be signed by private keys.

### Step 1: Get Raw Transaction Data

Use the [hex API endpoint](https://blockstream.info/api/tx/f4184fc596403b9d638783cf57adfe4c75c605f6356fbc91338530e9831e9e16/hex) to retrieve the complete transaction bytes.

https://github.com/user-attachments/assets/79158ab1-d0df-4b3b-8c1e-e61940d5bd84

### Step 2: Build the Message to Sign

It's impossible to sign a message containing its own signature, so the `scriptSig` is replaced by the `scriptPubKey` of the transaction output being spent.

```javascript
function createTxMessage() {
  let msg = ""

  // version:
  msg += "01000000"

  // number of inputs:
  msg += "01"

  // hash of tx being spent by input #0:
  msg += "c997a5e56e104102fa209c6a852dd90660a20b2d9c352423edce25857fcd3704"

  // index of output of tx being spent by input #0:
  msg += "00000000"

  // scriptPubKey of output being spent by input #0:
  msg += "43410411db93e1dcdb8a016b49840f8c53bc1eb68a382e97b1482ecad7b148a6909a5cb2e0eaddfb84ccf9744464f82e160bfa9b8b64f9d4c03f999b8643f656b412a3ac"
  
  // input #0 sequence:
  msg += "ffffffff"

  // number of outputs:
  msg += "02"

  // output #0 value (10 BTC):
  msg += "00ca9a3b00000000"

  // output #0 scriptPubKey (Hal Finney's public key):
  msg += "434104ae1a62fe09c5f51b13905f07f06b99a2f7159b2225f374cd378d71302f"
  msg += "a28414e7aab37397f554a7df5f142c21c1b7303b8a0626f1baded5c72a704f7e"
  msg += "6cd84cac"

  // output #1 value (40 BTC - change):
  msg += "00286bee00000000"

  // output #1 scriptPubKey (Satoshi's public key for change):
  msg += "43410411db93e1dcdb8a016b49840f8c53bc1eb68a382e97b1482ecad7b148a6"
  msg += "909a5cb2e0eaddfb84ccf9744464f82e160bfa9b8b64f9d4c03f999b8643f656"
  msg += "b412a3ac"

  // locktime:
  msg += "00000000"

  // SIGHASH FLAG (SIGHASH_ALL):
  msg += "01000000"
  
  return msg
}
```

### What are SIGHASH Flags?

**SIGHASH flags** determine which parts of a transaction are signed by a signature. The value `01000000` represents `SIGHASH_ALL`, which signs the entire transaction.

 **Result:** Transaction message successfully constructed!

---

## ðŸ”¨ Verify the Signature

### Step 1: Hash the Transaction Digest

The serialized transaction data is too long to sign or verify with ECDSA directly. Bitcoin uses **double SHA-256** hashing to compress it into a signable message.

**Why double hashing?** To prevent length-extension attacks where an attacker could calculate the hash of a concatenated message without knowing the original.

```javascript
const crypto = require('crypto');

function msg_to_integer(msg) {
  // Convert hex string to Buffer
  const buffer = Buffer.from(msg, 'hex');
  
  // First SHA256 hash
  const hash1 = crypto.createHash('sha256').update(buffer).digest();
  
  // Second SHA256 hash (double-SHA256)
  const hash2 = crypto.createHash('sha256').update(hash1).digest();
  
  // Convert the 32-byte digest to BigInt
  const hashHex = hash2.toString('hex');
  const integer = BigInt('0x' + hashHex);
  
  return integer;
}
```

**Result:**
```
55192368857469264807759274836848938481238746809645363588732068292162212317977
```

---

### Step 2: Decode the Signature

Satoshi's signature is encoded in **DER format** (a subset of ASN.1). We need to extract two 32-byte numbers called **R** and **S**, each prefixed by `0220`.

```
Signature DER:
304402204e45e16932b8af514961a1d3a1a25fdf3f4f7732e9d624c6c61548ab5fb8cd410220181522ec8eca07de4860a4acdd12909d831cc56cbbac4622082221a8768d1d09
```

**Extracted Values:**
- **R value:** `4e45e16932b8af514961a1d3a1a25fdf3f4f7732e9d624c6c61548ab5fb8cd41`
- **S value:** `181522ec8eca07de4860a4acdd12909d831cc56cbbac4622082221a8768d1d09`

---

### Step 3: Decode the Public Key

Public keys are points on the ECDSA curve with x and y coordinates. The first byte `04` means "uncompressed" (unlike `02` and `03` from Chapter 4).

```javascript
const pubKey = "11db93e1dcdb8a016b49840f8c53bc1eb68a382e97b1482ecad7b148a6909a5cb2e0eaddfb84ccf9744464f82e160bfa9b8b64f9d4c03f999b8643f656b412a3";

// Split into x and y coordinates (32 bytes each)
const midpoint = Math.floor(pubKey.length / 2);
const x_coordinate = pubKey.slice(0, midpoint);
const y_coordinate = pubKey.slice(midpoint);
```

**Extracted Values:**
- **X coordinate:** `11db93e1dcdb8a016b49840f8c53bc1eb68a382e97b1482ecad7b148a6909a5c`
- **Y coordinate:** `b2e0eaddfb84ccf9744464f82e160bfa9b8b64f9d4c03f999b8643f656b412a3`

---

### Step 4: Implement ECDSA Verification

Now we have everything needed to perform the ECDSA verification algorithm!

```javascript
const secp256k1 = require('@savingsatoshi/secp256k1js')

const GE = secp256k1.GE
const FE = secp256k1.FE
const ORDER = secp256k1.ORDER

// Message digest:
const msg = 0x7a05c6145f10101e9d6325494245adf1297d80f8f38d4d576d57cdba220bcb19n;

// Signature values:
const sig_r = 0x4e45e16932b8af514961a1d3a1a25fdf3f4f7732e9d624c6c61548ab5fb8cd41n;
const sig_s = 0x181522ec8eca07de4860a4acdd12909d831cc56cbbac4622082221a8768d1d09n;

// Public key values:
const pubkey_x = 0x11db93e1dcdb8a016b49840f8c53bc1eb68a382e97b1482ecad7b148a6909a5cn;
const pubkey_y = 0xb2e0eaddfb84ccf9744464f82e160bfa9b8b64f9d4c03f999b8643f656b412a3n;

function verify(sig_r, sig_s, pubkey_x, pubkey_y, msg) {
  // Create curve point representation of the public key
  const key = new GE(new FE(pubkey_x), new FE(pubkey_y));
  
  // Check signature value ranges
  if (sig_r == 0n || sig_r >= ORDER) {
    console.log('invalid r value');
    return false;
  }
  if (sig_s == 0n || sig_s >= ORDER) {
    console.log('invalid s value');
    return false;
  }
  
  // Helper: modular multiplicative inverse
  function invert(value, modulus = ORDER) {
    let x0 = 0n;
    let x1 = 1n;
    let a = value;
    let m = modulus;

    while (a > 1n) {
      const q = a / m;
      let t = m;
      m = a % m;
      a = t;
      t = x0;
      x0 = x1 - q * x0;
      x1 = t;
    }

    if (x1 < 0n)
      x1 += modulus;

    return x1;
  }
  
  const sig_s_inverted = invert(sig_s);
  
  // ECDSA verification algorithm:
  // u1 = m / s mod n
  const u1 = (msg * sig_s_inverted) % ORDER;
  
  // u2 = r / s mod n
  const u2 = (sig_r * sig_s_inverted) % ORDER;
  
  // R = u1 * G + u2 * PublicKey
  const R = (secp256k1.G.mul(u1)).add(key.mul(u2));
  
  // Verify: R.x mod n == r
  return R.x.equals(new FE(sig_r));
}

// Test the verification
const isValid = verify(sig_r, sig_s, pubkey_x, pubkey_y, msg);
```

 **Success!** Satoshi's signature is valid. We've verified a signature that has been checked by every Bitcoin full node since 2010!

---

## ðŸŽ­ Part 2: The Vanderpoole Challenge

### The Claim

Vanderpoole claims: *"I have control of the private key Satoshi used to sign the first-ever Bitcoin transaction."*

Let's verify this claim using the **Bitcoin message signing protocol**.

---

### Step 1: Prepare Vanderpoole's Message

The Bitcoin message signing protocol uses this format:

```
[size of prefix][prefix][size of message][message]
```

```javascript
const crypto = require('crypto');

let text = "I am Vanderpoole and I have control of the private key Satoshi\n"
text += "used to sign the first-ever Bitcoin transaction confirmed in block #170.\n"
text += "This message is signed with the same private key."

function encode_message(text) {
  const prefix = Buffer.from('Bitcoin Signed Message:\n', 'ascii');
  const message = Buffer.from(text, 'ascii');
  
  // Encode variable length integer
  function varint(n) {
    if (n < 0xfd) {
      return Buffer.from([n]);
    } else if (n <= 0xffff) {
      const buf = Buffer.allocUnsafe(3);
      buf.writeUInt8(0xfd, 0);
      buf.writeUInt16LE(n, 1);
      return buf;
    }
    throw new Error('Value too large');
  }
  
  const prefixLength = varint(prefix.length);
  const messageLength = varint(message.length);
  
  // Concatenate all parts
  const data = Buffer.concat([
    prefixLength,
    prefix,
    messageLength,
    message
  ]);
  
  // Double SHA-256 hash
  const hash1 = crypto.createHash('sha256').update(data).digest();
  const hash2 = crypto.createHash('sha256').update(hash1).digest('hex');
  
  return hash2;
}
```

**Result:** `73a16290e005b119b9ce0ceea52949f0bd4f925e808b5a54c631702d3fea1242`

---

### Step 2: Decode Vanderpoole's Signature

The signature is encoded in **base64**. We need the 32-byte **r** and **s** values.

```javascript
const vpSig = "H4vQbVD0pLK7pkzPto8BHourzsBrHMB3Qf5oYVmr741pPwdU2m6FaZZmxh4ScHxFoDelFC9qG0PnAUl5qMFth8k="

function decode_sig(vpSig) {
  const vpSigBytes = Buffer.from(vpSig, 'base64');
  
  // Remove first byte (metadata) and split into r and s
  const vpSigBytesPartOne = vpSigBytes.slice(1, 33);  // r
  const vpSigBytesPartTwo = vpSigBytes.slice(33, 65); // s
  
  const vpSigR = BigInt('0x' + vpSigBytesPartOne.toString('hex'));
  const vpSigS = BigInt('0x' + vpSigBytesPartTwo.toString('hex'));
  
  return [vpSigR, vpSigS];
}
```

---

### Step 3: Verify Against Satoshi's Key

```javascript
const publicKeyX = "0x11db93e1dcdb8a016b49840f8c53bc1eb68a382e97b1482ecad7b148a6909a5c"
const publicKeyY = "0xb2e0eaddfb84ccf9744464f82e160bfa9b8b64f9d4c03f999b8643f656b412a3"

const [r, s] = decode_sig(vpSig);
const msg = encode_message(text);
const keyGE = new GE(new FE(publicKeyX), new FE(publicKeyY));

const isValid = verify(r, s, keyGE, msg);
```

**Result:** `false`

âŒ The signature did NOT originate from Satoshi's public key!

---

### Step 4: Find the Real Key

Let's test Vanderpoole's signature against multiple keys:

```javascript
const keys = [
  "04bbb554daf8811b95c8af5272fa8b4e2d6335bf19fff24d3187b8781497299aa4d27c900c367e4e506d671a4ea3aa50843f182a090d701f3bc8e6578d2455d81e",
  "04cc679cd88b28444049aa9db8f88864ace38f79ba6310d0d3f027c9462a9f420befaaf888ce372cbf6f0ece99e5ada86436c960c1c0840a588ea7dbd78187445d",
  "049d57ded01d3a7652a957cf86fd4c3d2a76e76e83d3c965e1dca45f1ee06630636b8bcbc3df3fbc9669efa2ccd5d7fa5a89fe1c0045684189f01ea915b8a746a6",
  "0461bfb73040740c12f57146b3a7f2ccfd75b6cd2a0d5df7a789cfaeb77bda4dcd222df570946cb6de62d6b1a939f55da85859f575e84ba86c67c4aa97d85ba516",
  "042a87d97397b2c43dff63670e38e78db159daa0e1070ec42181d0ed44a7d1aa508d42bd9759659c4a3194dea56da71325fb25acda6ee931cd8b93172b5d0f3c8f",
  "04d1cdabaea3be5d8161b93b7e20b0375cefee0a36259d654185555deff881406a421384e927328e2dcb5ed87103365ef3007bd31e12591e5d1c56c83516db26ec"
]

function verify_keys(keys) {
  for (let i = 0; i < keys.length; i++) {
    const keyHex = keys[i];
    
    // Extract x and y coordinates (remove '04' prefix)
    const xHex = keyHex.slice(2, 66);
    const yHex = keyHex.slice(66);
    
    // Create GE point
    const keyGE = new GE(new FE(BigInt('0x' + xHex)), new FE(BigInt('0x' + yHex)));
    
    // Try to verify
    const isValid = verify(sig_r_fe, sig_s_fe, keyGE, msg_fe);
    
    if (isValid) {
      return keyHex;
    }
  }
  
  return null;
}

const validKey = verify_keys(keys);
```

**Result:** 
```
049d57ded01d3a7652a957cf86fd4c3d2a76e76e83d3c965e1dca45f1ee06630636b8bcbc3df3fbc9669efa2ccd5d7fa5a89fe1c0045684189f01ea915b8a746a6
```

âœ… **The signature is valid for THIS public key** - but it's Vanderpoole's key, not Satoshi's!

---

## ðŸŽ“ Key Takeaways

### The Big Lesson: **Don't Trust, Verify!**

1. **Digital signatures** prove ownership without revealing the private key
2. **ECDSA** uses elliptic curve mathematics to create and verify signatures
3. **Double SHA-256** hashing prevents length-extension attacks
4. **DER encoding** serializes signature components (R and S values)
5. **Bitcoin message signing** uses a specific protocol with prefix encoding
6. **Verification is trustless** - you can prove claims mathematically
7. **Claims must be verified** - Vanderpoole's claim was false!

*This chapter demonstrates the cryptographic foundation that enables trustless verification in Bitcoin and shows why the mantra "Don't trust, verify" is fundamental to the system.*
