# Chapter 5: Digital Signatures & Verification

## ðŸ” Don't Trust, Verify

We can use Elliptic Curve math to derive a public key from a private key. The public key can be shared as a unique identifier and the private key is used to prove a person has control of that identifier. That proof is called a **SIGNATURE**.

### How Signatures Work

- **To create a signature:** You need a message and a private key
- **To verify a signature:** Anyone can verify it with a copy of the message and the corresponding public key

---

## Finding Satoshi's Signature

### Block #170: The First Bitcoin Transaction

[Block #170](https://blockstream.info/tx/f4184fc596403b9d638783cf57adfe4c75c605f6356fbc91338530e9831e9e16?expand) contains the first bitcoin transaction made from Satoshi to Hal Finney. 

**Task:** Retrieve the scriptSig from the input - it contains Satoshi's signature!

```
scriptSig (asm)
OP_PUSHBYTES_71 304402204e45e16932b8af514961a1d3a1a25fdf3f4f7732e9d624c6c61548ab5fb8cd410220181522ec8eca07de4860a4acdd12909d831cc56cbbac4622082221a8768d1d0901
```

---

## Locating Satoshi's Public Key

The public key is stored along with the bitcoin Satoshi generated by mining [block #9](https://blockstream.info/tx/0437cd7f8525ceed2324359c2d0ba26006d92d856a9c20fa0241106ee5a597c9?output:0&expand).

The public key lives between the script commands `OP_PUSHBYTES` and `OP_CHECKSIG`:

```
0411db93e1dcdb8a016b49840f8c53bc1eb68a382e97b1482ecad7b148a6909a5cb2e0eaddfb84ccf9744464f82e160bfa9b8b64f9d4c03f999b8643f656b412a3
```

---

## Deriving the Message from the Transaction

The Bitcoin protocol has a very specific algorithm for creating messages from transactions so they can be signed by private keys.

### Step 1: Get Raw Transaction Data

Use the [hex API endpoint](https://blockstream.info/api/tx/f4184fc596403b9d638783cf57adfe4c75c605f6356fbc91338530e9831e9e16/hex) to retrieve the complete transaction bytes.

https://github.com/user-attachments/assets/79158ab1-d0df-4b3b-8c1e-e61940d5bd84

### Step 2: Build the Message to Sign

It's impossible to sign a message containing its own signature, so the `scriptSig` is replaced by the `scriptPubKey` of the transaction output being spent.

```javascript
function createTxMessage() {
  let msg = ""

  // version:
  msg += "01000000"

  // number of inputs:
  msg += "01"

  // hash of tx being spent by input #0:
  msg += "c997a5e56e104102fa209c6a852dd90660a20b2d9c352423edce25857fcd3704"

  // index of output of tx being spent by input #0:
  msg += "00000000"

  // scriptPubKey of output being spent by input #0:
  msg += "43410411db93e1dcdb8a016b49840f8c53bc1eb68a382e97b1482ecad7b148a6909a5cb2e0eaddfb84ccf9744464f82e160bfa9b8b64f9d4c03f999b8643f656b412a3ac"
  
  // input #0 sequence:
  msg += "ffffffff"

  // number of outputs:
  msg += "02"

  // output #0 value (10 BTC):
  msg += "00ca9a3b00000000"

  // output #0 scriptPubKey (Hal Finney's public key):
  msg += "434104ae1a62fe09c5f51b13905f07f06b99a2f7159b2225f374cd378d71302f"
  msg += "a28414e7aab37397f554a7df5f142c21c1b7303b8a0626f1baded5c72a704f7e"
  msg += "6cd84cac"

  // output #1 value (40 BTC - change):
  msg += "00286bee00000000"

  // output #1 scriptPubKey (Satoshi's public key for change):
  msg += "43410411db93e1dcdb8a016b49840f8c53bc1eb68a382e97b1482ecad7b148a6"
  msg += "909a5cb2e0eaddfb84ccf9744464f82e160bfa9b8b64f9d4c03f999b8643f656"
  msg += "b412a3ac"

  // locktime:
  msg += "00000000"

  // SIGHASH FLAG (SIGHASH_ALL):
  msg += "01000000"
  
  return msg
}
```

### What are SIGHASH Flags?

**SIGHASH flags** determine which parts of a transaction are signed by a signature. The value `01000000` represents `SIGHASH_ALL`, which signs the entire transaction.

 **Result:** Transaction message successfully constructed!

---

## ðŸ”¨ Verify the Signature

### Step 1: Hash the Transaction Digest

The serialized transaction data is too long to sign or verify with ECDSA directly. Bitcoin uses **double SHA-256** hashing to compress it into a signable message.

**Why double hashing?** To prevent length-extension attacks where an attacker could calculate the hash of a concatenated message without knowing the original.

```javascript
const crypto = require('crypto');

function msg_to_integer(msg) {
  // Convert hex string to Buffer
  const buffer = Buffer.from(msg, 'hex');
  
  // First SHA256 hash
  const hash1 = crypto.createHash('sha256').update(buffer).digest();
  
  // Second SHA256 hash (double-SHA256)
  const hash2 = crypto.createHash('sha256').update(hash1).digest();
  
  // Convert the 32-byte digest to BigInt
  const hashHex = hash2.toString('hex');
  const integer = BigInt('0x' + hashHex);
  
  return integer;
}
```

**Result:**
```
55192368857469264807759274836848938481238746809645363588732068292162212317977
```

---

### Step 2: Decode the Signature

Satoshi's signature is encoded in **DER format** (a subset of ASN.1). We need to extract two 32-byte numbers called **R** and **S**, each prefixed by `0220`.

```
Signature DER:
304402204e45e16932b8af514961a1d3a1a25fdf3f4f7732e9d624c6c61548ab5fb8cd410220181522ec8eca07de4860a4acdd12909d831cc56cbbac4622082221a8768d1d09
```

**Extracted Values:**
- **R value:** `4e45e16932b8af514961a1d3a1a25fdf3f4f7732e9d624c6c61548ab5fb8cd41`
- **S value:** `181522ec8eca07de4860a4acdd12909d831cc56cbbac4622082221a8768d1d09`

---

### Step 3: Decode the Public Key

Public keys are points on the ECDSA curve with x and y coordinates. The first byte `04` means "uncompressed" (unlike `02` and `03` from Chapter 4).

```javascript
const pubKey = "11db93e1dcdb8a016b49840f8c53bc1eb68a382e97b1482ecad7b148a6909a5cb2e0eaddfb84ccf9744464f82e160bfa9b8b64f9d4c03f999b8643f656b412a3";

// Split into x and y coordinates (32 bytes each)
const midpoint = Math.floor(pubKey.length / 2);
const x_coordinate = pubKey.slice(0, midpoint);
const y_coordinate = pubKey.slice(midpoint);
```

**Extracted Values:**
- **X coordinate:** `11db93e1dcdb8a016b49840f8c53bc1eb68a382e97b1482ecad7b148a6909a5c`
- **Y coordinate:** `b2e0eaddfb84ccf9744464f82e160bfa9b8b64f9d4c03f999b8643f656b412a3`

---

### Step 4: Implement ECDSA Verification

Now we have everything needed to perform the ECDSA verification algorithm!

```javascript
const secp256k1 = require('@savingsatoshi/secp256k1js')

const GE = secp256k1.GE
const FE = secp256k1.FE
const ORDER = secp256k1.ORDER

// Message digest:
const msg = 0x7a05c6145f10101e9d6325494245adf1297d80f8f38d4d576d57cdba220bcb19n;

// Signature values:
const sig_r = 0x4e45e16932b8af514961a1d3a1a25fdf3f4f7732e9d624c6c61548ab5fb8cd41n;
const sig_s = 0x181522ec8eca07de4860a4acdd12909d831cc56cbbac4622082221a8768d1d09n;

// Public key values:
const pubkey_x = 0x11db93e1dcdb8a016b49840f8c53bc1eb68a382e97b1482ecad7b148a6909a5cn;
const pubkey_y = 0xb2e0eaddfb84ccf9744464f82e160bfa9b8b64f9d4c03f999b8643f656b412a3n;

function verify(sig_r, sig_s, pubkey_x, pubkey_y, msg) {
  // Create curve point representation of the public key
  const key = new GE(new FE(pubkey_x), new FE(pubkey_y));
  
  // Check signature value ranges
  if (sig_r == 0n || sig_r >= ORDER) {
    console.log('invalid r value');
    return false;
  }
  if (sig_s == 0n || sig_s >= ORDER) {
    console.log('invalid s value');
    return false;
  }
  
  // Helper: modular multiplicative inverse
  function invert(value, modulus = ORDER) {
    let x0 = 0n;
    let x1 = 1n;
    let a = value;
    let m = modulus;

    while (a > 1n) {
      const q = a / m;
      let t = m;
      m = a % m;
      a = t;
      t = x0;
      x0 = x1 - q * x0;
      x1 = t;
    }

    if (x1 < 0n)
      x1 += modulus;

    return x1;
  }
  
  const sig_s_inverted = invert(sig_s);
  
  // ECDSA verification algorithm:
  // u1 = m / s mod n
  const u1 = (msg * sig_s_inverted) % ORDER;
  
  // u2 = r / s mod n
  const u2 = (sig_r * sig_s_inverted) % ORDER;
  
  // R = u1 * G + u2 * PublicKey
  const R = (secp256k1.G.mul(u1)).add(key.mul(u2));
  
  // Verify: R.x mod n == r
  return R.x.equals(new FE(sig_r));
}

// Test the verification
const isValid = verify(sig_r, sig_s, pubkey_x, pubkey_y, msg);
```

 **Success!** Satoshi's signature is valid. We've verified a signature that has been checked by every Bitcoin full node since 2010!

---

## Key Takeaways

1. **Digital signatures** prove ownership without revealing the private key
2. **ECDSA** uses elliptic curve mathematics to create and verify signatures
3. **Double SHA-256** hashing prevents length-extension attacks
4. **DER encoding** is used to serialize signature components (R and S values)
5. **Verification** requires the message, signature, and public key - no private key needed

*This chapter demonstrates the cryptographic foundation that enables trustless verification in Bitcoin.*
